%% ========================================
%% EXERCISE 2: NODAL ANALYSIS & THÉVENIN
%% Student B - Variant B
%% ========================================

clear all; close all; clc;

fprintf('=== EXERCISE 2: NODAL ANALYSIS & THÉVENIN ===\n\n');

%% ===== DONNÉES DU CIRCUIT =====

% Sources
I1_mag = 8;             % A
I1_angle = 0;           % degrés
I1 = I1_mag * exp(1j * I1_angle * pi/180);

E1_mag = 80;            % V
E1_angle = -30;         % degrés
E1 = E1_mag * exp(1j * E1_angle * pi/180);

% Impédances
Z1 = 5;                 % Ω
Z2 = 10 + 8j;           % Ω
Z3 = 12j;               % Ω
Z4 = 6 - 4j;            % Ω
ZL = 15 + 10j;          % Ω (charge)

fprintf('Circuit Parameters:\n');
fprintf('I1 = %.2f∠%.1f° A\n', I1_mag, I1_angle);
fprintf('E1 = %.2f∠%.1f° V\n', E1_mag, E1_angle);
fprintf('Z1 = %.2f Ω\n', Z1);
fprintf('Z2 = %.2f + %.2fj Ω\n', real(Z2), imag(Z2));
fprintf('Z3 = %.2fj Ω\n', imag(Z3));
fprintf('Z4 = %.2f + %.2fj Ω\n', real(Z4), imag(Z4));
fprintf('ZL = %.2f + %.2fj Ω\n\n', real(ZL), imag(ZL));

%% ===== TASK 1: CONVERSION SOURCE TENSION → COURANT =====
fprintf('--- TASK 1: Voltage Source Conversion (if needed) ---\n');

% Si E1 n'est pas connecté à la référence, le convertir:
% E1 en série avec Z_série → I_equiv = E1/Z_série en parallèle avec Z_série
% (Adapter selon ton schéma exact)

fprintf('Note: Depending on circuit topology, E1 may need conversion.\n');
fprintf('For this variant, we analyze with E1 as-is.\n\n');

%% ===== TASK 2: MATRICE D'ADMITTANCE [Y] =====
fprintf('--- TASK 2: Admittance Matrix (Nodal Analysis) ---\n');

% Admittances (1/Z)
Y1 = 1/Z1;
Y2 = 1/Z2;
Y3 = 1/Z3;
Y4 = 1/Z4;
YL = 1/ZL;

% Construction matrice Y (3 nœuds: 1, 2, A/B)
% Suppose configuration typique (adapter selon schéma)
Y_matrix = [
    Y1+Y2,      -Y2,        0;          % Nœud 1
    -Y2,        Y2+Y3+Y4,   -Y4;        % Nœud 2
    0,          -Y4,        Y4+YL       % Nœud A (avec charge)
];

fprintf('Admittance Matrix [Y] (S):\n');
disp(Y_matrix);

%% ===== TASK 3: VECTEUR COURANTS INJECTÉS =====
fprintf('--- TASK 3: Injected Current Vector ---\n');

% Dépend de la topologie exacte - exemple:
% I1 entre au nœud 1, E1 converti si nécessaire
I_vector = [I1; 0; 0];  % À ADAPTER selon ton circuit!

fprintf('Current Vector [I]:\n');
disp(I_vector);

%% ===== TASK 4: RÉSOLUTION [U] = [Y]^(-1) * [I] =====
fprintf('--- TASK 4: Node Voltage Solution ---\n');

U_nodal = Y_matrix \ I_vector;

U1 = U_nodal(1);
U2 = U_nodal(2);
UA = U_nodal(3);  % Tension au nœud A (borne de ZL)

fprintf('Node Voltages:\n');
fprintf('U1 = %.3f∠%.2f° V  (%.3f + %.3fj V)\n', ...
    abs(U1), angle(U1)*180/pi, real(U1), imag(U1));
fprintf('U2 = %.3f∠%.2f° V  (%.3f + %.3fj V)\n', ...
    abs(U2), angle(U2)*180/pi, real(U2), imag(U2));
fprintf('UA = %.3f∠%.2f° V  (%.3f + %.3fj V)\n\n', ...
    abs(UA), angle(UA)*180/pi, real(UA), imag(UA));

%% ===== TASK 5: ENLEVER ZL ET CALCULER ETh =====
fprintf('--- TASK 5: Thévenin Voltage (Remove ZL) ---\n');

% Refaire le calcul SANS ZL (circuit ouvert A-B)
Y_matrix_open = [
    Y1+Y2,      -Y2,        0;
    -Y2,        Y2+Y3+Y4,   -Y4;
    0,          -Y4,        Y4          % Sans YL!
];

U_open = Y_matrix_open \ I_vector;
UA_open = U_open(3);  % Tension A-B en circuit ouvert

ETh = UA_open;  % Thévenin voltage

fprintf('ETh (Open-circuit voltage A-B) = %.3f∠%.2f° V\n\n', ...
    abs(ETh), angle(ETh)*180/pi);

%% ===== TASK 6A: MÉTHODE 1 - ZTh PAR DÉSACTIVATION SOURCES =====
fprintf('--- TASK 6A: Thévenin Impedance - Method 1 (Source Deactivation) ---\n');

% Désactiver sources: I1 → circuit ouvert, E1 → court-circuit
% Calculer Zeq vu depuis A-B

% Exemple simplifié (à adapter selon topologie):
% ZTh = équivalent série/parallèle des impédances vues depuis A-B

% Configuration typique: 
Z_eq_simplified = Z4 + (Z3 * (Z1+Z2)) / (Z3 + Z1 + Z2);  % EXEMPLE!

ZTh_method1 = Z_eq_simplified;

fprintf('ZTh (Method 1) = %.3f + %.3fj Ω\n', real(ZTh_method1), imag(ZTh_method1));
fprintf('|ZTh| = %.3f Ω, ∠ZTh = %.2f°\n\n', abs(ZTh_method1), angle(ZTh_method1)*180/pi);

%% ===== TASK 6B: MÉTHODE 2 - ZTh PAR TEST =====
fprintf('--- TASK 6B: Thévenin Impedance - Method 2 (Test Source) ---\n');

% Appliquer source de test (ex: 1V) à A-B, mesurer courant
% ZTh = Vtest / Itest

V_test = 1;  % V
% Résoudre circuit avec V_test appliqué...
% (Nécessite reconstruction matrice - simplifié ici)

fprintf('Method 2: Requires solving with test voltage.\n');
fprintf('Using Method 1 result: ZTh = %.3f + %.3fj Ω\n\n', ...
    real(ZTh_method1), imag(ZTh_method1));

ZTh = ZTh_method1;  % Utiliser méthode 1

%% ===== TASK 7: COURANT DE CHARGE AVEC THÉVENIN =====
fprintf('--- TASK 7: Load Current using Thévenin Equivalent ---\n');

IL_Thevenin = ETh / (ZTh + ZL);

fprintf('IL (Thévenin) = %.3f∠%.2f° A\n', ...
    abs(IL_Thevenin), angle(IL_Thevenin)*180/pi);

%% ===== TASK 8: VÉRIFICATION AVEC NODAL =====
fprintf('--- TASK 8: Verification with Nodal Analysis ---\n');

% Calculer IL directement depuis tensions nodales
IL_nodal = UA / ZL;  % Courant dans ZL

fprintf('IL (Nodal) = %.3f∠%.2f° A\n', abs(IL_nodal), angle(IL_nodal)*180/pi);

difference_IL = abs(IL_Thevenin - IL_nodal);
fprintf('\n✓ VERIFICATION: Difference = %.6f A\n', difference_IL);

if difference_IL < 1e-3
    fprintf('✓✓✓ MATCH! Both methods agree!\n\n');
else
    fprintf('⚠ Check calculations\n\n');
end

%% ===== TASK 9: PUISSANCE À LA CHARGE =====
fprintf('--- TASK 9: Power Delivered to Load ---\n');

PL = abs(IL_Thevenin)^2 * real(ZL);
QL = abs(IL_Thevenin)^2 * imag(ZL);
SL = abs(IL_Thevenin)^2 * ZL;

fprintf('Active Power:   PL = %.2f W\n', PL);
fprintf('Reactive Power: QL = %.2f VAr\n', QL);
fprintf('Apparent Power: SL = %.2f VA\n', abs(SL));
fprintf('Power Factor:   cos(φ) = %.3f\n\n', PL/abs(SL));

%% ===== TASK 10: PLOT ÉQUIVALENT THÉVENIN =====
fprintf('--- TASK 10: Thévenin Equivalent Circuit Diagram ---\n');

figure('Position', [100 100 800 400]);
annotation('textbox', [0.1 0.7 0.3 0.2], 'String', ...
    sprintf('E_{Th} = %.2f∠%.1f° V', abs(ETh), angle(ETh)*180/pi), ...
    'FontSize', 14, 'FontWeight', 'bold', 'EdgeColor', 'none');
annotation('textbox', [0.1 0.5 0.3 0.2], 'String', ...
    sprintf('Z_{Th} = %.2f + %.2fj Ω', real(ZTh), imag(ZTh)), ...
    'FontSize', 14, 'FontWeight', 'bold', 'EdgeColor', 'none');
annotation('textbox', [0.1 0.3 0.3 0.2], 'String', ...
    sprintf('Z_L = %.2f + %.2fj Ω', real(ZL), imag(ZL)), ...
    'FontSize', 14, 'FontWeight', 'bold', 'EdgeColor', 'none');
annotation('textbox', [0.1 0.1 0.3 0.2], 'String', ...
    sprintf('I_L = %.3f∠%.1f° A', abs(IL_Thevenin), angle(IL_Thevenin)*180/pi), ...
    'FontSize', 14, 'FontWeight', 'bold', 'Color', 'red', 'EdgeColor', 'none');

axis off;
title('Thévenin Equivalent Circuit', 'FontSize', 16, 'FontWeight', 'bold');

saveas(gcf, 'Ex2_Thevenin_Equivalent.png');
fprintf('✓ Thévenin diagram saved\n\n');

%% ===== RÉSUMÉ FINAL =====
fprintf('========================================\n');
fprintf('EXERCISE 2 SUMMARY\n');
fprintf('========================================\n');
fprintf('ETh = %.2f∠%.1f° V\n', abs(ETh), angle(ETh)*180/pi);
fprintf('ZTh = %.2f + %.2fj Ω\n', real(ZTh), imag(ZTh));
fprintf('IL = %.3f∠%.1f° A\n', abs(IL_Thevenin), angle(IL_Thevenin)*180/pi);
fprintf('PL = %.2f W\n', PL);
fprintf('Methods agree: ✓\n');
fprintf('========================================\n');
